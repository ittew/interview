## 多维数组扁平化
```js
var arr = [[1,2],[3,4,5,[6,7]]]
function flatten(arr){
  return [].concat(
    ...arr.map(item => Array.isArray(item) ? flatten(item) : item)
  )
}
console.log(flatten(arr))
```

## 变量隐式转换
```js
var a = { },
    b = { key:'b' },
    c = { key:'c' };
a[b] = 123;
a[c] = 456;
console.log(a[b]) // 456
/* 首先a[b] 这里面b最后显示成什么？
  关于变量隐式转换，对象的a[]这种写法，里面添加的是属性名称--string类型
  所以a[b]，b的原类型是object，目标是string类型。实际上是执行了a[b.toString()]
  同理a[c]也一样
  a[b.toString()]=123;
  a[c.toString()]=456;
  Object类型的变量 执行toString() 结果都是同样的字符串。----"[object Object]"
  所以a["[object Object]"]=123;  a["[object Object]"]=456;
*/
```

## 连等号执行顺序
```js
var y = 1, x = y = typeof x;
console.log(x) // undefiend
/* var y; var x  // x ,y 此时都是undefiend  ---> y = 1
  连等号从右向左执行
  typeof x -->undefiend(字符串) -->y = undefined(字符串) --> x = undefied(字符串)
*/
```

## toString 特例
```js
// 对象.toString() ---> [object Object]
console.log({a: 1}.toString()=='[object Object]');
// 纯数字.toString()  .在前面是纯数字时会被当成 小数点
// 10.toString() ==> (10.)toString() 报错
// 10..toString() ==> (10.).toString() '10'
```

## 对象引用
```js
var a = {n:1}
var b = a
a = {n:2}
a.x = a
console.log(a.x) // {n: 2, x: { n:2, x: {n:2, x: ...}}} 无限
console.log(b) // {n:1}
console.log(b.x) // undefined


// = 赋值操作 不但会将右边的值保存到左边的变量中, 而且还会返回等号右边的值 a = {n:2} // {n:2}
// A=B=C连等赋值真正的运算规则是 B=C; A=B 即连续赋值是从右至左永远只取等号右边的表达式结果赋值到等号左侧。
var a = {n:1}
var b = a
a.x = a = {n:2}
console.log(a) // {n: 2}
console.log(a.x) // undefiend
console.log(b) // {n:1, x: {n:2}}
console.log(b.x) // {n:2}
/*解答思路：
1. 首先将对象{n:1}赋值给a变量 再将a赋值给b 这是一层浅拷贝过程 所以a和b变量都指向同一个对象{n:1}
2. 由于点运算符优先于赋值运算符所以先在{n：1}对象中创建了一个x属性 {n:1，x:（暂时无值）} 这个过程 因为运算符优先级的原因 赋值符号还未执行的时候就已经完成了
3. 再然后执行 a = {n:2} 此时a的引用地址发生了改变 从对象{n:1}指向了{n:2}
4. a.x此时指向的是 {n:1，x:（暂时无值）}对象 然后将{n：2} 赋值给了a.x属性 此时A对象{n:1， x：{n：2}}
5. 此时的a.x属性的父级对象a的初始引用地址是A对象 而A对象赋值给了b变量 所以你能在b.x中得到对象{n：2}
6. 原对象地址因无人引用他 被垃圾回收机制回收了 对象被赋值了B对象{n：2} 所以原有的a.x为undefined
*/
```

